"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useCacheMap = exports.parseVueDocument = exports.parseVueDocuments = exports.TeleportSourceMap = exports.EmbeddedDocumentSourceMap = exports.SourceMap = void 0;
const vueTs = require("@volar/vue-typescript");
const shared = require("@volar/shared");
const reactivity_1 = require("@vue/reactivity");
const source_map_1 = require("@volar/source-map");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const untrack_1 = require("./utils/untrack");
const vue_code_gen_1 = require("@volar/vue-code-gen");
const vscode = require("vscode-languageserver-protocol");
class SourceMap extends source_map_1.SourceMapBase {
    constructor(sourceDocument, mappedDocument, _mappings) {
        super(_mappings);
        this.sourceDocument = sourceDocument;
        this.mappedDocument = mappedDocument;
        this._mappings = _mappings;
    }
    getSourceRange(start, end, filter) {
        for (const mapped of this.getRanges(start, end !== null && end !== void 0 ? end : start, false, filter)) {
            return mapped;
        }
    }
    getMappedRange(start, end, filter) {
        for (const mapped of this.getRanges(start, end !== null && end !== void 0 ? end : start, true, filter)) {
            return mapped;
        }
    }
    getSourceRanges(start, end, filter) {
        return this.getRanges(start, end !== null && end !== void 0 ? end : start, false, filter);
    }
    getMappedRanges(start, end, filter) {
        return this.getRanges(start, end !== null && end !== void 0 ? end : start, true, filter);
    }
    *getRanges(start, end, sourceToTarget, filter) {
        const startIsNumber = typeof start === 'number';
        const endIsNumber = typeof end === 'number';
        const toDoc = sourceToTarget ? this.mappedDocument : this.sourceDocument;
        const fromDoc = sourceToTarget ? this.sourceDocument : this.mappedDocument;
        const startOffset = startIsNumber ? start : fromDoc.offsetAt(start);
        const endOffset = endIsNumber ? end : fromDoc.offsetAt(end);
        for (const mapped of super.getRanges(startOffset, endOffset, sourceToTarget, filter)) {
            yield getMapped(mapped);
        }
        function getMapped(mapped) {
            if (startIsNumber) {
                return mapped;
            }
            return [{
                    start: toDoc.positionAt(mapped[0].start),
                    end: toDoc.positionAt(mapped[0].end),
                }, mapped[1]];
        }
    }
}
exports.SourceMap = SourceMap;
class EmbeddedDocumentSourceMap extends SourceMap {
    constructor(embeddedFile, sourceDocument, mappedDocument, _sourceMap) {
        super(sourceDocument, mappedDocument, _sourceMap.mappings);
        this.embeddedFile = embeddedFile;
        this.sourceDocument = sourceDocument;
        this.mappedDocument = mappedDocument;
    }
}
exports.EmbeddedDocumentSourceMap = EmbeddedDocumentSourceMap;
class TeleportSourceMap extends SourceMap {
    constructor(embeddedFile, document, teleport) {
        super(document, document, teleport.mappings);
        this.embeddedFile = embeddedFile;
        this.document = document;
    }
    *findTeleports(start, end, filter) {
        for (const [teleRange, data] of this.getMappedRanges(start, end, filter ? data => filter(data.toTarget) : undefined)) {
            yield [teleRange, data.toTarget];
        }
        for (const [teleRange, data] of this.getSourceRanges(start, end, filter ? data => filter(data.toSource) : undefined)) {
            yield [teleRange, data.toSource];
        }
    }
}
exports.TeleportSourceMap = TeleportSourceMap;
function parseVueDocuments(vueLsCtx, tsLs) {
    // cache map
    const vueDocuments = useCacheMap(vueFile => {
        return parseVueDocument(vueFile, tsLs);
    });
    // reactivity
    const embeddedDocumentsMap = (0, reactivity_1.computed)(() => {
        const map = new Map();
        for (const vueDocument of getAll()) {
            for (const sourceMap of vueDocument.refs.sourceMaps.value) {
                map.set(sourceMap.mappedDocument, vueDocument);
            }
        }
        return map;
    });
    const embeddedDocumentsMapLsType = (0, reactivity_1.computed)(() => {
        const map = new Map();
        for (const vueDocument of getAll()) {
            for (const sourceMap of vueDocument.refs.sourceMaps.value) {
                map.set(sourceMap.mappedDocument.uri, sourceMap);
            }
        }
        return map;
    });
    const teleportsMapLsType = (0, reactivity_1.computed)(() => {
        const map = new Map();
        for (const vueDocument of getAll()) {
            for (const teleport of vueDocument.refs.teleports.value) {
                map.set(teleport.mappedDocument.uri, teleport);
            }
        }
        return map;
    });
    return {
        getAll: (0, untrack_1.untrack)(getAll),
        get: (0, untrack_1.untrack)((uri) => {
            const fileName = shared.uriToFsPath(uri);
            const vueFile = vueLsCtx.sourceFiles.get(fileName);
            if (vueFile) {
                return vueDocuments.get(vueFile);
            }
        }),
        fromEmbeddedDocument: (0, untrack_1.untrack)((document) => {
            return embeddedDocumentsMap.value.get(document);
        }),
        sourceMapFromEmbeddedDocumentUri: (0, untrack_1.untrack)((uri) => {
            return embeddedDocumentsMapLsType.value.get(uri);
        }),
        teleportfromEmbeddedDocumentUri: (0, untrack_1.untrack)((uri) => {
            return teleportsMapLsType.value.get(uri);
        }),
        fromEmbeddedLocation: (0, untrack_1.untrack)(function* (uri, start, end, filter, sourceMapFilter) {
            if (uri.endsWith(`/${vueTs.localTypes.typesFileName}`))
                return;
            if (end === undefined)
                end = start;
            const sourceMap = embeddedDocumentsMapLsType.value.get(uri);
            if (sourceMap) {
                if (sourceMapFilter && !sourceMapFilter(sourceMap))
                    return;
                for (const vueRange of sourceMap.getSourceRanges(start, end, filter)) {
                    yield {
                        uri: sourceMap.sourceDocument.uri,
                        range: vueRange[0],
                        sourceMap,
                        data: vueRange[1],
                    };
                }
            }
            else {
                yield {
                    uri,
                    range: {
                        start,
                        end,
                    },
                };
            }
        }),
    };
    function getAll() {
        return vueLsCtx.sourceFiles.getAll().map(vueFile => vueDocuments.get(vueFile));
    }
}
exports.parseVueDocuments = parseVueDocuments;
function parseVueDocument(vueFile, tsLs) {
    // cache map
    let documentVersion = 0;
    const embeddedDocumentVersions = new Map();
    const embeddedDocumentsMap = useCacheMap(embeddedFile => {
        var _a;
        const uri = shared.fsPathToUri(embeddedFile.fileName);
        const newVersion = ((_a = embeddedDocumentVersions.get(uri.toLowerCase())) !== null && _a !== void 0 ? _a : 0) + 1;
        embeddedDocumentVersions.set(uri.toLowerCase(), newVersion);
        return vscode_languageserver_textdocument_1.TextDocument.create(uri, shared.syntaxToLanguageId(embeddedFile.fileName.split('.').pop()), newVersion, embeddedFile.content);
    });
    const sourceMapsMap = useCacheMap(embedded => {
        return new EmbeddedDocumentSourceMap(embedded.file, document.value, embeddedDocumentsMap.get(embedded.file), embedded.sourceMap);
    });
    let templateScriptData = {
        components: [],
        componentItems: [],
    };
    // reactivity
    const document = (0, reactivity_1.computed)(() => vscode_languageserver_textdocument_1.TextDocument.create(shared.fsPathToUri(vueFile.fileName), vueFile.fileName.endsWith('.md') ? 'markdown' : 'vue', documentVersion++, vueFile.text));
    const sourceMaps = (0, reactivity_1.computed)(() => {
        return vueFile.getAllEmbeddeds().map(embedded => sourceMapsMap.get(embedded));
    });
    const teleports = (0, reactivity_1.computed)(() => {
        return vueFile.getTeleports().map(teleportAndFile => {
            const embeddedDocument = embeddedDocumentsMap.get(teleportAndFile.file);
            const sourceMap = new TeleportSourceMap(teleportAndFile.file, embeddedDocument, teleportAndFile.teleport);
            return sourceMap;
        });
    });
    const templateTagsAndAttrs = (0, reactivity_1.computed)(() => {
        var _a;
        const htmlComputed = vueFile.getSfcTemplateLanguageCompiled();
        const ast = (_a = vueFile.getSfcVueTemplateCompiled()) === null || _a === void 0 ? void 0 : _a.ast;
        const tags = new Map();
        const attrs = new Set();
        if (ast && htmlComputed) {
            (0, vue_code_gen_1.walkElementNodes)(ast, node => {
                var _a;
                if (!tags.has(node.tag)) {
                    tags.set(node.tag, []);
                }
                const offsets = tags.get(node.tag);
                const startTagHtmlOffset = node.loc.start.offset + node.loc.source.indexOf(node.tag);
                const startTagTemplateOffset = htmlComputed.mapping({ start: startTagHtmlOffset, end: startTagHtmlOffset });
                if (startTagTemplateOffset !== undefined) {
                    offsets.push(startTagTemplateOffset.start);
                }
                const endTagHtmlOffset = node.loc.start.offset + node.loc.source.lastIndexOf(node.tag);
                const endTagTemplateOffset = htmlComputed.mapping({ start: endTagHtmlOffset, end: endTagHtmlOffset });
                if (endTagTemplateOffset !== undefined) {
                    offsets.push(endTagTemplateOffset.end);
                }
                for (const prop of node.props) {
                    if (prop.type === 7 /* CompilerDOM.NodeTypes.DIRECTIVE */
                        && ((_a = prop.arg) === null || _a === void 0 ? void 0 : _a.type) === 4 /* CompilerDOM.NodeTypes.SIMPLE_EXPRESSION */
                        && prop.arg.isStatic) {
                        attrs.add(prop.arg.content);
                    }
                    else if (prop.type === 6 /* CompilerDOM.NodeTypes.ATTRIBUTE */) {
                        attrs.add(prop.name);
                    }
                }
            });
        }
        return {
            tags,
            attrs,
        };
    });
    return {
        uri: shared.fsPathToUri(vueFile.fileName),
        file: vueFile,
        embeddedDocumentsMap,
        sourceMapsMap,
        getTemplateData: (0, untrack_1.untrack)(getTemplateData),
        getSourceMaps: (0, untrack_1.untrack)(() => sourceMaps.value),
        getDocument: (0, untrack_1.untrack)(() => document.value),
        getTemplateTagsAndAttrs: (0, untrack_1.untrack)(() => templateTagsAndAttrs.value),
        refs: {
            sourceMaps,
            teleports,
        },
    };
    function getTemplateData() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const options = {
                includeCompletionsWithInsertText: true, // if missing, { 'aaa-bbb': any, ccc: any } type only has result ['ccc']
            };
            const file = (_a = vueFile.getAllEmbeddeds().find(e => e.file.fileName.indexOf('.__VLS_template.') >= 0)) === null || _a === void 0 ? void 0 : _a.file;
            if (file && file.content.indexOf(vueTs.SearchTexts.Components) >= 0) {
                const document = embeddedDocumentsMap.get(file);
                let components = yield (tsLs === null || tsLs === void 0 ? void 0 : tsLs.doComplete(shared.fsPathToUri(file.fileName), document.positionAt(file.content.indexOf(vueTs.SearchTexts.Components)), options));
                if (components) {
                    const items = components.items
                        .filter(entry => entry.kind !== vscode.CompletionItemKind.Text)
                        .filter(entry => entry.label.indexOf('$') === -1 && !entry.label.startsWith('_'));
                    const componentNames = items.map(entry => entry.label);
                    templateScriptData = {
                        components: componentNames,
                        componentItems: items,
                    };
                }
            }
            return templateScriptData;
        });
    }
}
exports.parseVueDocument = parseVueDocument;
function useCacheMap(parse) {
    const cache = new WeakMap();
    return {
        get,
    };
    function get(source) {
        let result = cache.get(source);
        if (!result) {
            result = parse(source);
            cache.set(source, result);
        }
        return result;
    }
}
exports.useCacheMap = useCacheMap;
//# sourceMappingURL=vueDocuments.js.map